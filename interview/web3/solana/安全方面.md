### 1. 账户与权限控制 
- 1.限制调用权限： 使用 #[account(has_one = authority)] 自动验证账户 authority 字段绑定，且该账户必须是signer
```rust
#[derive(Accounts)]
pub struct Update<'info> {
    #[account(mut, has_one = authority)]
    pub data_account: Account<'info, Data>,
    pub authority: Signer<'info>,
}
```
### PDA 安全机制
#### 什么是Pda？
- PDA 是通过种子（seed）和程序 ID 计算得出的地址，没有对应私钥，无法被外部账户控制，只能由程序签名操作。

#### 安全优势：
    - 避免用户伪造账户地址
    - 保证账户属于程序控制
    - 使账户地址可预测、可管理

###  Cross-Program Invocation (CPI) 安全风险与防范
#### 风险：
    -  传入账户权限不明或错误导致授权泄漏
    -  重入攻击（Reentrancy）导致状态多次修改
    -  外部程序恶意篡改调用数据
#### 防范：
- 仅传递必要的账户和 signer
- 使用 PDA 账户防止伪造
- 在关键路径设置状态锁，防止重入
- 使用 #[account(mut)] 严格声明可变账户
- 严格校验 CPI 返回状态，配合事件日志

### 整数溢出和边界保护
- checked_add(), checked_sub()

| 错误场景          | 说明             | 解决方案                      |
| ------------- | -------------- | ------------------------- |
| 未校验 signer 权限 | 账户操作无权限校验，易被攻击 | 使用 `Signer` 类型及 `has_one` |
| 未用 PDA 管理状态账户 | 用户可伪造账户地址      | 强制使用 PDA 地址管理账户           |
| CPI 账户权限传递错误  | 外部调用权限放开导致越权   | 严格限制 CPI 账户参数             |
| 租金不足导致账户被冻结   | 账户无租金，状态不能更新   | 初始化时预存足够租金                |
| 整数运算未边界校验     | 溢出导致状态异常       | 使用安全运算接口                  |

### 使用squads 进行多签控制

#### 在我们的 Solana 项目中，为了保障合约升级和资产操作的安全性，我们使用了 Squads 多签系统，通过链上的提案 + 成员签名机制，控制了程序的升级权限。我们部署合约时，将 upgrade authority 设置为 squads PDA，任何升级都必须通过提案和多成员签名才能生效，从而防止了单点私钥滥用或者恶意升级。同时，Squads 的执行代理机制（Multisig signer PDA）确保执行安全又自动化，团队管理更规范。

### 如何优化费用
#### 在我们开发 Solana 上的 DeFi 协议和一次大型 NFT mint 活动中，我主导了链上性能与费用优化的相关工作。
- 在 DeFi 项目中，我们通过将多个 PDA 合并为一个结构体、复用用户的 ATA，减少账户租金和指令开销，使程序体积缩小近 60%。
- 同时，引入 Address Lookup Table 压缩账户列表，客户端层面通过账户缓存和预模拟交易机制，避免无效交易，最终将核心交互的链费优化到约 0.00001 SOL。
- 而在 NFT mint 高并发场景中，我们应对网络拥堵，采用动态优先费用机制、高优先级调度关键交易，同时引入 ALT 和后台缓冲队列，模拟失败重试，成功将交易失败率从 60% 降低到 5% 以下，有效保障了关键交易被顺利打包并控制了整体链上费用。
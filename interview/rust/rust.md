1.Rust 的核心设计理念是什么
    核心是 内存安全 与 零成本抽象，在不牺牲性能的前提下，通过所有权系统、借用检查器等机制，消除空指针、野指针等内存安全问题，同时避免垃圾回收（GC）的性能开销。
2.解释 Rust 的 “所有权（Ownership）” 规则？
    1.每个值在 Rust 中都有一个 “所有者” 变量。
    2.同一时间，一个值只能有一个所有者。
    3.当所有者离开作用域（如函数结束、代码块闭合），值会被自动销毁（释放内存）。
3.“借用（Borrowing）” 和 “引用（Reference）” 的区别与规则？
    1.引用是获取值的地址的方式（&T 不可变引用，&mut T 可变引用），借用是通过引用使用值的行为，二者本质关联，常统称 “借用”。    
    2.借用规则：1）同一时间，要么多个不可变引用，要么一个可变引用；2）引用必须始终有效（不出现悬垂引用）
4.什么是 “生命周期（Lifetime）”？Rust 为什么需要它？
    1.生命周期是指引用保持有效的作用域范围，用于编译器静态检查引用有效性，避免悬垂引用。    
    2.Rust 无 GC，需通过生命周期标注,让编译器确认引用在使用时未失效，保证内存安全。
5.Rust 中 Option 和 Result 枚举的作用是什么？
    1.Result<T, E>：处理 “操作可能成功（Ok(T)）或失败（Err(E)）” 的场景，强制开发者显式处理错误（如 match、? 运算符），而非隐式忽略错误。
6.&str 和 String 的区别是什么？分别在什么场景使用？
    | 类型 | 本质 | 可变性 | 内存位置 | 适用场景 |
    | &str | 字符串切片（引用） | 不可变 | 栈（引用）+ 堆 | 读取字符串、传递字符串引用 |
    | String | 动态字符串（所有者） | 可变 | 堆（存储数据） | 动态修改字符串（增删改） |
7.Rust 中的 “智能指针” 有哪些？各自作用？
    1.Box<T>：在堆上存储数据，栈上保留指向堆的指针，用于递归类型、转移所有权等场景（无额外性能开销）。
    2.Rc<T>：单线程引用计数智能指针，允许同一数据被多个所有者共享，通过计数判断何时释放内存（线程不安全）。
    3.Arc<T>：多线程安全的引用计数智能指针，基于 Rc<T> 增加原子操作，支持跨线程共享数据。
    4.RefCell<T>：运行时借用检查器，允许在不可变引用的情况下修改数据（如在递归类型中），但会在运行时检查借用规则，若违反会panic。
8.什么是 “内部可变性（Interior Mutability）”？与 “外部可变性” 的区别？
    1.内部可变性：允许通过不可变引用修改数据（如 RefCell<T>、Mutex<T>），安全性由运行期检查保障。
    2.外部可变性:仅允许通过可变引用（&mut T）修改数据，安全性由编译期检查保障。
    3.区别：核心是 “可变性检查时机”，内部可变性适合需共享且修改的数据场景（如单线程共享状态）。
9.Rust 如何实现多线程安全？Send 和 Sync trait 的作用？
    1.多线程安全基础：Rust 通过 Send 和 Sync 两个标记 trait 静态判断类型是否可跨线程安全传递 / 共享。
    2.Send：标记类型可安全地 “转移所有权” 到另一个线程（如 String 实现 Send，Rc<T> 不实现 Send）。
    3.Sync：标记类型可安全地 “共享引用” 给多个线程（如 Arc<T> 实现 Sync，RefCell<T> 不实现 Sync）。
    4.工具：通过 Mutex<T>（互斥锁）、RwLock<T>（读写锁）等同步原语，实现多线程对数据的安全修改。
10.Rust 的 “模式匹配（Pattern Matching）” 有哪些常用场景？
    1.处理枚举（如 match option { Some(x) => x, None => 0 }）；
    2.解构变量（如 let (x, y) = (1, 2); 解构元组，let Person { name, age } = p; 解构结构体）；
    3.条件判断（如 if let Some(x) = option { ... } 简化单分支匹配）。
11.? 运算符的作用是什么？使用时有什么限制？
    1.作用：简化 Result/Option 类型的错误处理，替代 match 或 unwrap()。若值为 Ok(x)/Some(x)，则提取 x 继续执行；若为 Err(e)/None，则直接返回该错误 / 空值。
    2.限制：仅能在返回类型为 Result<T, E> 或 Option<T> 的函数中使用（需保证错误类型匹配）

1. 在项目中如何选择 Box<T>、Rc<T> 和 Arc<T>？它们的核心适用场景是什么？
    1.Box<T>：适用于单一所有权场景，如存储递归类型（如链表节点）、转移大型数据避免栈拷贝、或在编译期确定大小的类型中嵌入动态大小类型（DST）。项目中最基础的堆内存分配工具，无额外性能开销。
    2.Rc<T>：适用于单线程内多所有权场景，如同一线程中多个组件共享只读数据（如配置、常量缓存）。通过引用计数管理生命周期，线程不安全，不能跨线程传递。
    3.Arc<T>：适用于多线程内多所有权场景，如同一线程中多个组件共享可变数据（如状态、缓存）。通过原子操作管理生命周期，线程安全，不能跨线程传递。

2.项目中如何处理 Rust 的错误？Result<T, E> 和 Option<T> 分别用在什么场景？如何简化错误处理逻辑？
    1.Option<T>：用于表示 “值存在或不存在”（无错误原因），如从哈希表中查询键（存在则 Some(value)，不存在则 None）、处理可能为空的变量。
    2.Result<T, E>：用于表示 “操作成功（Ok(T)）或失败（Err(E)）”（需携带错误原因），如文件读写（失败则返回 std::io::Error）、网络请求（失败则返回自定义错误）。